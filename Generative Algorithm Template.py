import pygame
import time
import random
from pygame import midi

pygame.midi.init()
Player = pygame.midi.Output(3) #Defines where the output of the Midi goes from here. In this case, the third MIDI channel on my computer is the virtual cable that goes to Ableton

String = 'o--o-o-ooo-o-o---o-'
'''
Rules: Tone list and Rhythm string. Only uptil 16th notes allowed, notes will be on until next note comes in
The composition will be divided into different peroids, periods will be divided into phrases, phrases will be divided into bars.
phrases will be connected to each other by similar rhythmic or tonal ideas and periods will be seperated by moods that we want to bring set by the mood parameter.

The scale and tempo will be chosen according to the mood.
The chord progression will be chosen by constrained randomness. Constraints depend on mood.
Rhythm will be generated by constrained randomness. Constraints depend on the stiffness.
The chord progression and rhythm will combine to give the first draft of the melody bars.
Little embelishments will be made.
The bars for the first phrase will be ordered randomly
The first phrase is created
For two of the four bars of every succeeding phrase either a tonal idea is copied, or a rhythmic idea is copied
and the second phrase is generated.
The first and last bars of each phrase are constrained tonally
Four phrases will make one period.
5 periods will be made (at the moment with exactly similar constraints)
The periods will be ordered randomly and make a small song piece.
'''

''' INITIALIZATIONS'''
#Our User Constraint Knobs:
Stiffness = 0.5 #from 0 to 1
Mood = 'Happy' #Mood can be 'Happy','Sad','Dark'

#Our Functional Knobs (Each Constraint combination has a fixed setting of Functional knobs)
Tempo = 180 #The quarter notes per minute
ScaleType = 'minor' #Can be 'minor','major' or 'diminished'
RootNote = 'C' #Can be any note basically
Tension = 0.5 #From 0 to 1 , outlines the base probability that a tension making note is added as opposed to a non-tension making note
MainTimeScale = 2 #This is the average number of bars a chord should play for
NoteDensity = 4 #Average number of notes in a bar
SteptoJumpRatio = 0.5 #Outlines the base probability that the next note will be a step note as opposed to a jump note


#Our Derived Useful Numbers
Note16Duration = 15*2/Tempo #Duration of 16th Notes in seconds

#We create a Note to Midi dictionary:
Note = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'] #Note Characters
Octave = ['0','1','2','3','4','5','6'] #Octave Numbers
NotesToMidi = {} #Empty Dictionary
n = 0 #This variable increments the Midi numbers as the notes get higher
for number in Octave:
    for note in Note:
        #Creates a directory such as: NotesToMidi['C#0'] = 24
        NotesToMidi[note+number] = 24 + n
        n += 1
#We create the inverse dictionary as well
MidiToNotes = dict([[a,b] for (b,a) in NotesToMidi.items()])

##Creating a bunch of Notes we can play:
#We first create a Note class:
class Note:
    def __init__(self,MidiNote,Channel,Player):
        self.MidiNote = MidiNote
        self.NormalNote = MidiToNotes[MidiNote]
        self.Channel = Channel
        self.Player = Player
    def play(self,velocity):
        Player.note_on(self.MidiNote,velocity,self.Channel)
    def stop(self):
        Player.note_off(self.MidiNote,0,self.Channel)

#Creating Instances of the Note only for the notes involved in the scale:
#There are three instruments. The cello, the piano melody, the piano chords.
#So we start with the root note in the octave needed and then go up from there
#First we create the scaleType method which can output the set of midi notes given the root note and the scaleType
def ScaleNotes(RootMidi,OctavesUp,ScaleType):
    ScaleFormula = {'major': [2,2,1,2,2,2,1], 'minor':  [2,1,2,2,1,2,2], 'diminished': [2,1,2,1,2,1,2]}
    NoteNumbers = [RootMidi]
    for octave in range(OctavesUp):
        for jump in ScaleFormula[ScaleType]:
            NoteNumbers.append(NoteNumbers[-1]+jump)
    return NoteNumbers
#Now we create the allowed midi notes for the instruments to stay in scale
CelloMidis = ScaleNotes(NotesToMidi[RootNote+'0'],4,ScaleType) #The cello starts from the root  on octave 0 and goes up 4 octaves
PianoChordsMidis = ScaleNotes(NotesToMidi[RootNote+'1'],3,ScaleType) #The piano chords start on octave 1 and go up 3 octaves
PianoMelodyMidis = ScaleNotes(NotesToMidi[RootNote+'2'],4,ScaleType) #The piano melody starts on octave 1 and goes up 4 octaves
Cello = []
PianoChords = []
PianoMelody = []
for note in CelloMidis:
    Cello.append(Note(note,1,Player)) #Cello is Channel 2
for note in PianoChordsMidis:
    PianoChords.append(Note(note,2,Player)) #Piano Chords are Channel 3
for note in PianoMelodyMidis:
    PianoMelody.append(Note(note,0,Player)) #Piano Melody is Channel 1



def TensionCalculator(MelodyTones):
    OverallTension = 0
    TensionMap = [-2,1,-1,1,-1,1,2] #Note Tension values from root note
    for tone in range(len(MelodyTones)):
        OverallTension += TensionMap[tone%7]*MelodyTones[tone]
    return OverallTension
        
def DistributionNormalizer(Distribution):
    Total = 0
    ReturnDistribution = Distribution
    for unit in Distribution:
        Total += unit
    for index in len(Distribution):
        ReturnDistribution[index] = (1/Total)*Distribution[index]
    return ReturnDistribution

def random10(cutoff):
    a = random.random()
    if a>cutoff:
        return 1
    else:
        return 0

#Random Melody generator.
#This is the part you can edit to insert your own Algorithm.
#Melody [0] contains the bass lines
#Melody [1] contains the melody lines
#at the moment they are a 16 by 64 matrix, with 64 time subintervals and 16 notes,.
#these 16 notes are placed on the scale specified by the scale chosen in the initializations.
def RandomMelodyGenerator():
    Melody = [0,0]
    Melody[0] = [[random10(0.93) for x in range(16)]for y in range(64)]
    Melody[1] = [[random10(0.98) for x in range(16)]for y in range(64)]
    return Melody

#Plays the Melody
def MelodyPlayer(Melody,loops):
    #Count In
    for i in range(8):
        PianoMelody[12].play(120)
        Cello[12].play(120)
        time.sleep(Note16Duration)
        PianoMelody[12].stop()
        Cello[12].stop()
        

    #Random Melody Player
    for looptimes in range(loops):
        for noteinbeat in range(32):
            memory = []
            memory2 = []
            for noteintone in range(16):
                if Melody[0][noteinbeat][noteintone] != 0:
                    PianoMelody[noteintone].play(100)
                    memory.append(noteintone)
                if Melody[1][noteinbeat][noteintone] != 0:
                    Cello[noteintone+0].play(100)
                    memory2.append(noteintone)
            time.sleep(Note16Duration)
            for noteintone in memory:
                PianoMelody[noteintone].stop()
            for noteintone in memory2:
                Cello[noteintone+0].stop()



Melody = RandomMelodyGenerator()
MelodyPlayer(Melody,8)


